# 3장. 타입 추론



### 개요

기존 산업계에서 사용하는 프로그래밍 언어는 타입을 직접 명시한다. 

그러나 학술계에서 사용되는 언어는 오래 전부터 정교한 타입 추론 시스템을 가지고 있었다. 

학술계 언어의 발전에따라 기존 산업계의 언어에서도 타입 추론 시스템이 추가되었고, C++은 auto, 자바는 var를 추가하는 식으로 발전했다.

타입스크립트도 타입 추론을 적극적으로 수행한다. 

3장에서는 다음과 같은 것을 배운다.

* 타입 추론에서 발생할 수 있는 몇 가지 문제와 그에 대한 해법
* 타입 스크립트가 타입을 추론하는 방법
* 타입 선언을 작성해야 할 때
* 타입 추론이 가능하더라도 명시적으로 타입 선언을 작성하는 것이 필요한 상황





## 아이템 19. 추론 가능한 타입을 사용해 장황한 코드 방지하기

### 타입 스크립트의 타입 추론 시스템은 생각보다 정교하다.

모든 코드의 변수에 타입을 선언하는 것은 비생산적이며 형편없는 스타일이다.

```tsx
let x:number = 12;
let x = 12;
```

위 코드에서 x에 마우스를 올려 보면 타입이 number로 이미 추론되어 있음을 확인할 수 있다.



타입스크립트는 더 복잡한 객체도 추론할 수 있으며, 다음과 같은 함수도 어떤 타입을 반환하는 지 정확하게 알고 있다.

```tsx
function square(nums: number[]){
  return nums.map(x => x * x);
}
const squares = square([1, 2, 3, 4]); // 타입은 number[]
```



심지어 타입스크립트는 우리들의 예상보다 더 정확하게 추론하기도 한다.

```tsx
const axis1: string = 'x'; // 타입은 string
const axis2 = 'y'; // 타입은 y
```

 string이 아닌 'y'가 더 정확한 타입이다.



비구조화 할당문은 모든 지역 변수 타입이 추론되게한다. 여기서 명시적 타입 구문을 넣으면 불필요한 타입 선언으로 오히려 코드가 번잡해진다.

```tsx
interface Product {
  id: string;
  name: string;
  price: number;
}

function logProduct(product: Product) {
  const { id, name, price } = product;
  console.log(id, name, price);
}
```



### 명시적 타입 구문이 필요한 상황

정보가 부족해 타입 스크립트가 타입을 판단하기 어려운 상황도 존재한다. 이럴 때는 명시적 타입 구문이 필요하다.



> ***이상적인 타입스크립트 코드는 함수/메서드 시그니처에 타입 구문을 포함하지만,*** 
>
> ***함수 내에서 생성된 지역 변수에는 타입 구문을 넣지 않는다.***



구문을 생략하여 방해 되는 것을 최소화하고, 코드를 읽는 사람이 구현 로직에 집중할 수 있게 하는 것이 좋다.

함수 매개변수에 타입 구문을 생략하는 경우도 있다.

```tsx
function parseNumber(str: string, base=10){
  // ...
}
```

위와 같은 경우엔 기본값이 10이므로 base 타입은 number로 추론된다.



> ***보통 타입 정보가 있는 라이브러리에서,*** 
>
> ***콜백 콜백 함수의 매개변수 타입은 자동으로 추론된다.***



```tsx
// 이렇게 하는 것은 좋지 않다.
app.get('/health', (request: express.Request, response: express.Response) => {
  response.send("OK");
})

// 이렇게 합시당
app.get('/health', (request, response) => {
  response.send("OK");
})
```

위와 같은 코드에서, express HTTP 서버 라이브러리를 사용하는 경우 타입 선언은 필요 없다.





> ***타입이 추론됨에도 타입을 명시하고 싶은 상황이 있다.*** ***바로 객체 리터럴을 정의할 때이다.***



```tsx
type Product = {
  name: string;
  id: string;
  price: number;
};

const elmo: Product = {
  name: "Tickle Me Elmo",
  id: "12312313",
  price: 30
};

const furby = {
  name: "Furby",
  id: 1231231231,
  price: 35
};

const logProduct = (product: Product) => console.log(product);

logProduct(furby); // ERROR: ~~형식의 매개변수는 'Product' 형식에 할당될 수 없다... 어쩌구저쩌구
```

위와 같이 타입을 명시하면 잉여 속성 체크가 동작한다.

만약, 위의 코드처럼 furby에 타입을 할당하지 않으면, 잉여 속성 체크가 동작하지 않는다.

따라서 객체를 선언한 곳이 아닌, 객체를 사용하는 곳에서 타입 오류가 발생한다.



타입 구문을 제대로 명시하면 실제로 실수가 발생한 부분에 오류를 표시한다.

```tsx
const furby: Product = {
  name: "Furby",
  id: 1231231231,	// ERROR: number는 string에 할당할 수 없습니다...
  price: 35
};
```



> ***함수의 반환에도 타입을 명시하여 오류를 방지할 수 있다.***



타입 추론이 가능할지라도, 구현상의 오류가 함수를 호출한 곳 까지 영향을 끼치지 않도록 타입 구문을 명시하는 것이 좋다.

반환 타입을 명시하면, 구현상의 오류가 사용자 코드의 오류로 표시되지 않는다.

반환 타입을 사용하는 이점은 두 가지 더 있다.

1. 함수에 대해 더욱 명확하게 알 수 있다. 
2. 명명된 타입을 사용할 수 있다.
3. 반환 값을 별도의 타입으로 정의하면 타입에 대한 주석을 작성할 수 있다.



### 정리

* 타입스크립트가 타입 추론이 가능하다면 타입 구문을 작성하지 않는 것이 좋다.
* 이상적인 경우, 함수 / 메서드의 시그니처에는 타입 구문이 있지만, 함수 내의 지역 변수에는 타입 구문이 없다.
* 추론될 수 있는 경우라도 객체 리터럴과 함수 반환에는 타입 명시를 고려해야 한다.


