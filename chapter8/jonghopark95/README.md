# 8장. 타입스크립트로 마이그레이션하기



## 아이템 58. 모던 자바스크립트로 작성하기



타입스크립트는 타입 체크 기능 외에, 타입스크립트 코드를 특정 버전 자바스크립트로 컴파일 하는 기능도 가지고 있다.

옛날 버전의 JS 코드를 타입스크립트 컴파일러에서 동작하게 하면, 이후엔 최신 버전의 JS 코드를 써도 문제가 없다.

따라서 옛날 버전 자바스크립트 코드를 최신 버전으로 바꾸는 작업은 마이그레이션의 일부다.



### ECMAScript 모듈 사용하기

ES2015 이전에는 코드를 개별 모듈로 분할하는 표준 방법이 없었으나, 지금은 많아졌다.

* 여러 개의 <script> 태그 사용하기
* 직접 갖다 붙이기 (manual concatenation)
* MakeFile 기법
* NodeJS 스타일의 require 구문
* AMD 스타일의 define 콜백
* TS 자체 모듈 시스템
* ECMAScript 모듈 시스템



ES2015 부터는 Import, export 를 사용하는 ECMAScript 모듈이 표준이 되었다.

만약, 마이그레이션 대상 자바스크립트 코드가 단일 파일이거나 비표준 모듈 시스템을 사용중이라면 ES 모듈로 전환하는 것이 좋다.



### 프로토타입 대신 클래스 사용하기

과거에는 자바스크립트에서 프로토타입 기반의 객체 모델을 사용했지만, 현재는 ES6부터 도입된 클래스를 주로 사용한다.

TS 에서는 Convert functino to an ES2015 class 를 선택하면 간단히 클래스 객체로 변환할 수 있다.



### var 대신 let/const 사용하기

var 는 scope 규칙에 문제가 있다. 이 때문에, let / const 를 사용하는 것이 더 추천된다.

또 function 중첩문을 사용하는 경우, 호이스팅 때문에 예상치 못한 함수 호출이 발생할 수 있다. 대신 arrow function 을 사용하는 것이 좋다.



### for(;;) 대신 for-of 또는 배열 메서드 사용하기

과거엔 JS 배열 순회 시 C 스타일의 for 루프를 사용했으나, 모던 JS 는 for-of 가 있다.



### 함수 표현식 보다는 화살표 함수 사용하기

가급적 화살표 함수를 사용하는 것이 좋다. (this 바인딩)

그리고 컴파일러 옵션에 noImplicitThis 를 설정하면 TS 가 this 바인딩 관련 오류를 표시해준다.



### 단축 객체 표현과 구조 분해 할당 사용하기

객체 구조 분해를 사용하면 문법이 간결해지고 변수를 사용할 때 실수를 줄일 수 있으므로 적극적으로 사용해보는 것이 좋다.



### 함수 매개변수 기본값 사용하기

모던 JS 에서는 매개변수에 기본값을 직접 지정할 수 있다.

이는 Ts 에서 기본값을 기반으로 타입 추론이 가능해지므로 타입스크립트로 마이그레이션 할 때 매개변수에 타입 구문을 쓰지 않아도 된다.



### 저수준 프로미스나 콜백 대신 async/await 사용하기

async await 을 사용하면 비동기 코드에 타입 정보가 전달되어 타입 추론을 가능하게 한다.



### 연관 배열에 객체 대신 Map 과 Set 사용하기

```tsx
function countWords(text: string) {
  const counts: { [word: string]: number } = {};
  for (const word of text.split(/[\s,.]+/)) {
    counts[word] = 1 + (counts[word] || 0);
  }
  return counts;
}

console.log(countWords("objects have a constructor"));

// return
// {objects: 1, have: 1, a: 1, constructor: Object}
// objects: 1
// have: 1
// a: 1
// <constructor>: "Object"
```



constructor 라는 문자열이 주어지면 constructor 초기값이 있기 때문에 에러가 발생한다.

이런 문제를 방지하려면 Map 을 사용하는 것이 좋다.



```tsx
function countWords(text: string) {
  const counts = new Map<string, number>();
  for (const word of text.split(/[\s,.]+/)) {
    counts.set(word, 1 + (counts.get(word) || 0));
  }
  return counts;
}

console.log(countWords("objects have a constructor"));
```



### 타입스크립트에 use strict 넣지 않기

타입스크립트에서 수행하는 안전성 검사가 strict mode 보다 엄격한 체크를 하므로, 'use strict' 는 무의미하다.

실제로는 typescript compiler 가 생성하는 JS 코드에서 'use strict' 가 추가된다.

alwaysStrict 를 설정하면 자동으로 'use strict' 를 추가하므로 이 설정을 사용해야 한다.





## 아이템 59. 타입스크립트 도입 전에 @ts-check 와 JSDoc 으로 시험해 보기



@ts-check 지시자로 타입스크립트 전환 시 어떤 문제가 발생하는 지 미리 시험해 볼 수 있다.

그러나 @ts-check 지시자는 noImplicitAny 보다 더 헐거운 체크를 수행한다.



### 선언되지 않은 전역 변수

만약, 숨어 있는 변수를 제대로 인식시키기 위해선 별도로 타입 선언 파일을 만들어야 한다.

types.d.ts 를 만들면 오류가 해결이 된다.



### 정리

- 파일 상단에 // @ts-check 을 추가하면 자바스크립트에서도 타입 체크를 수행할 수 있다.
- 전역 선언, 서드파티 라이브러리의 타입 선언을 추가하는 법을 익혀야 한다.
- JSDoc 을 잘 활용하면 자바스크립트 상태에서도 타입 단언, 타입 추론을 할 수 있다.
- JSDoc 주석은 중간 단계 이므로 너무 공들일 필요 없다.



## 아이템 60. allowJS 로 타입스크립트와 자바스크립트 같이 사용하기

소규모 프로젝트는 한꺼번에 타입스크립트로 전화할 수 있지만, 대규모 프로젝트는 불가능하므로 점진적으로 전환해야 한다.

그러려면 마이그레이션 기간 동안 JS, TS 가 동시에 동작할 수 있어야 한다.



공존의 핵심은 allowJS 옵션인데, 이는 TS, JS 를 서로 import 할 수 있게 해준다.

또, 기존 빌드 과정에 타입스크립트 컴파일러를 추가해야 하며 모듈 단위로 TS로 전환하는 과정에서 테스트를 수행해야 하므로 allowJS 옵션이 필요하다.





## 아이템 61. 의존성 관계에 따라 모듈 단위로 전환하기

점진적 마이그레이션을 할 때는 모듈 단위로 각개격파하는 것이 이상적이다.

그러나 한 모듈을 골랐을 때, 해당 모듈이 다른 모듈로부터 의존하게 된다면 타입 오류가 발생하게 된다.

이를 방지하기 위해서는 최하단 모듈부터 작업을 시작해야 한다.



서드파티, 외부 API 모듈은 특정 모듈에 의존하지 않으므로, 먼저 해결하는 것이 좋다.



### 선언되지 않은 클래스 멤버

TS 에서는 멤버 변수를 반드시 선언해줘야 한다.



### 타입이 바뀌는 값

객체는 한꺼번에 생성해주어야 한다.



### 정리

- 마이그레이션의 첫 단계는 서드파티 모듈과 외부 API 호출에 대한 @types 를 추가하는 것이다.
- 의존성 관계도의 아래부터 위로 올라가며 마이그레이션 하면 된다.
- 이상한 설계를 발견해도 리펙터링하면 안된다. 이는 나중으로 목록을 만드는 것이 좋다.
- 타입스크립트로 전환하며 발견되는 일반적인 오류들을 놓치지 말아야 한다.



## 아이템 62. 마이그레이션 완성을 위해 noImplicitAny 설정하기

프로젝트를 .ts 로 전환했다면 매우 큰 진척을 이루어 낸 것이지만, 마지막 단계가 있다.

바로 타입의 강도를 높이는 것이다. any 로 선언된 타입은 오류가 숨어있으므로 진정한 마이그레이션이 진행되었다고 보기 어렵다.

타입 체크의 강도를 높이는 설정은 여러 가지가 있다.

- noImplicitAny
- strictNullChecks
- "strict": true



### 정리

- noImplicitAny 설정을 활성화하여 마이그레이션의 마지막 단계를 진행해야 한다.
  noImplicitAny 설정이 없다면 타입 선언과 관련된 실제 오류가 드러나지 않는다.
- noImplicitAny 를 전면 적용하기 전에 로컬에서부터 타입 오류를 점진적으로 수행해야 한다.



